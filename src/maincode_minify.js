//MIT License
//Copyright (c) 2026 kentaki65
S={t:{},g:{},c:0,o:0,i:0,d:{get false(){let e=S.t[S.c];do{let t=3*S.i;[e[t],e=>e][+(e[t+2]<S.g[e[t+1]])]()}while(++S.i<e.length/3);delete S.t[S.c],S.i=0}},run(e,t,n){let o=S.c-~t-1,i=S.t[o]=[S.t[o],[]][+!S.t[o]],l=i.length;i[l]=e,i[l+1]=[n,"0"][+!n],i[l+2]=S.o++},stop(e){S.g[e]=S.o++}},tick=()=>{S.d[!S.t[S.c]],S.c++};const pathState=new Map,previewTasks={},PARTICLE_STEP=1/120;let startCenterPos=null,endCenterPos=null;function previewCurveLoop(){for(let e of api.getPlayerIds()){let t=pathState.get(e);if(!t||!t.controlPoints||t.controlPoints.length<3)continue;if(null==previewTasks[e]&&(previewTasks[e]=0),previewTasks[e]>1&&(previewTasks[e]=0),!t.curve){if(!(t.controlPoints.length>=2))continue;t.curve=new BezierCurve(t.controlPoints)}let n=previewTasks[e],[o,i,l]=t.curve.getPoint(n);api.playParticleEffect({dir1:[-1,-1,-1],dir2:[1,1,1],pos1:[o,i,l],pos2:[o,i,l],texture:"square_particle",minLifeTime:5,maxLifeTime:5,minEmitPower:0,maxEmitPower:0,minSize:.6,maxSize:.6,manualEmitCount:1,gravity:[0,0,0],colorGradients:[{timeFraction:0,minColor:[60,60,150,1],maxColor:[200,200,255,1]}],velocityGradients:[{timeFraction:0,factor:1,factor2:1}],blendMode:1}),previewTasks[e]=n+PARTICLE_STEP}S.run(previewCurveLoop,1,"previewCurve")}function controlPointGlowLoop(){for(let e of api.getPlayerIds()){let t=pathState.get(e);if(t&&t.controlPoints)for(let n of t.controlPoints)api.playParticleEffect({dir1:[-1,-1,-1],dir2:[1,1,1],pos1:n,pos2:n,texture:"glint",minLifeTime:10,maxLifeTime:10,minEmitPower:0,maxEmitPower:0,minSize:5,maxSize:5,manualEmitCount:1,gravity:[0,0,0],colorGradients:[{timeFraction:0,minColor:[60,60,150,1],maxColor:[200,200,255,1]}],velocityGradients:[{timeFraction:0,factor:1,factor2:1}],blendMode:1})}S.run(controlPointGlowLoop,200,"controlGlow")}function updateUI(e,t){let n=pathState.get(e),o="　".repeat(10),i={str:o+"--ライン設置--\n"+o+"右クリック: 制御点を追加		/mode: モードの変更\n"+o+"左クリック: 最後の制御点を削除    /do: 生成\n"+o+`制御点数: ${String(n.controlPoints.length).padStart(2,"0")}点			モード:${n.mode}`,style:{fontSize:"15px"}};t?api.setClientOption(e,"crosshairText",[i]):api.setClientOption(e,"crosshairText","")}function fillSegment(e,t,n){let o=t[0]-e[0],i=t[1]-e[1],l=t[2]-e[2],s=Math.ceil(Math.max(Math.abs(o),Math.abs(i),Math.abs(l)));for(let r=0;r<=s;r++){let a=r/s;n(e[0]+o*a,e[1]+i*a,e[2]+l*a)}}function rebuildSection(e,t){if(!t.selectionPoints1||!t.selectionPoints2)return;let n=.5>=Math.abs(t.selectionPoints1[0]-t.selectionPoints2[0])?0:.5>=Math.abs(t.selectionPoints1[2]-t.selectionPoints2[2])?2:null;if(null===n)return;let o=2^n,i=Math.min(t.selectionPoints1[o],t.selectionPoints2[o]),l=Math.max(t.selectionPoints1[o],t.selectionPoints2[o]),s=Math.min(t.selectionPoints1[1],t.selectionPoints2[1]),r=Math.max(t.selectionPoints1[1],t.selectionPoints2[1]),a=new Map;for(let _=i;_<=l;_++)for(let $=s;$<=r;$++){let c=[t.selectionPoints1[0],$,t.selectionPoints1[2]];c[o]=_;let d=api.getBlockId(c[0],c[1],c[2]);if(0===d||1===d)continue;let u=_-t.selectionPoints1[o],p=$-t.selectionPoints1[1];a.set(`${u},${p}`,d)}t.selectedPoints=a,api.sendMessage(e,`選択完了
${a.size}個のブロックを追加しました`)}function getSnapFromBlock(e,t,n){let o=api.getBlockData(e,t,n);return o?.persisted?.shared?.snap??null}function applySnap(e,t,n,o,i){let l=pathState.get(e);if(!l)return;let s=l.controlPoints;s.length=0;let r=[t+.5,n+.5,o+.5],a;if(i.endHandle)a=[-i.endHandle[0],-i.endHandle[1],-i.endHandle[2],];else{let _=i.dir,$=i.handleLen??curve.getEndHandleLength();a=[_[0]*$,_[1]*$,_[2]*$]}let c=[r[0]+a[0],r[1]+a[1],r[2]+a[2],];s.push(r,c),l.curve=new BezierCurve(s),l.awaitingNextPoint=!0,api.sendMessage(e,"前の曲線と連続スナップしました")}onPlayerJoin=e=>{S.run(controlPointGlowLoop,1,"controlGlow"),S.run(previewCurveLoop,1,"previewCurve")};class BezierCurve{constructor(e){if(!e||e.length<2)throw Error("点が少なすぎるまたは無い");this.points=e.map(e=>[...e])}getPoint(e){let t=this.points.map(e=>[...e]);for(let n=t.length-1;n>0;n--)for(let o=0;o<n;o++)t[o][0]=t[o][0]*(1-e)+t[o+1][0]*e,t[o][1]=t[o][1]*(1-e)+t[o+1][1]*e,t[o][2]=t[o][2]*(1-e)+t[o+1][2]*e;return t[0]}getTangent(e){let t=this.points.map(e=>[...e]);for(let n=t.length-1;n>1;n--)for(let o=0;o<n;o++)t[o][0]=t[o][0]*(1-e)+t[o+1][0]*e,t[o][1]=t[o][1]*(1-e)+t[o+1][1]*e,t[o][2]=t[o][2]*(1-e)+t[o+1][2]*e;return[t[1][0]-t[0][0],t[1][1]-t[0][1],t[1][2]-t[0][2],]}getEndHandleLength(){let e=this.points.length;if(e<2)return 0;let t=this.points[e-1],n=this.points[e-2];return Math.hypot(t[0]-n[0],t[1]-n[1],t[2]-n[2])}}onPlayerClick=(e,t,n,o,i,l)=>{let s=pathState.get(e);s||(s={mode:"selection",controlPoints:[]},pathState.set(e,s));let r=api.getHeldItem(e);if(!r||!r.name.includes("Axe")){updateUI(e,!1);return}if("curve"===s.mode){updateUI(e,!0);let a=[n,o,i];if(s.controlPoints||(s.controlPoints=[]),t&&a.some(e=>void 0!==e)){let _=getSnapFromBlock(n,o,i);null!==_?applySnap(e,n,o,i,_):s.awaitingNextPoint?(api.sendMessage(e,"制御点を自動補正しました"),s.controlPoints.push([n,o,i]),s.awaitingNextPoint=!1):s.controlPoints.push([n,o,i]),api.sendMessage(e,"制御点を追加しました")}else s.controlPoints.pop(),api.sendMessage(e,"最後の制御点を削除しました");s.controlPoints.length>=2?s.curve=new BezierCurve(s.controlPoints):s.curve=null,api.log(s.controlPoints)}else"selection"===s.mode&&(t?null!=n&&null!=o&&null!=i&&(s.selectionPoints2=[n,o,i],api.sendMessage(e,`Pos2: ${[n,o,i]}`),rebuildSection(e,s),updateUI(e,!0)):null!=n&&null!=o&&null!=i&&(s.selectionPoints1=[n,o,i],api.sendMessage(e,`Pos1: ${[n,o,i]}`),updateUI(e,!0)))},playerCommand=(e,t)=>{let n=pathState.get(e);n||(n={mode:"selection",controlPoints:[]},pathState.set(e,n));let o=t.split(" "),i=o[0];if("mode"===i)return"selection"===n.mode?(n.mode="curve",api.sendMessage(e,'モードを"curve"に設定しました'),updateUI(e,!0),!0):(n.mode="selection",api.sendMessage(e,'モードを"selection"に設定しました'),updateUI(e,!0),!0);if("do"===i){if(!n||!n.curve||!n.selectedPoints)return api.sendMessage(e,"設置するブロックが未設定です"),!0;let l=n.curve,s=1/300,r=0,a=l.getPoint(0),_=new Set,$=l.getPoint(0);startCenterPos=[Math.round($[0]),Math.round($[1]),Math.round($[2]),];let c=l.getPoint(1);endCenterPos=[Math.round(c[0]),Math.round(c[1]),Math.round(c[2]),];let d=n.lastCurve,u,p,P,g;d&&(u=d.points.at(-1),p=d.points.at(-2),P=d.points.at(0),g=d.points.at(1));let f=(e,t,n,o)=>{let i=1023&e|(1023&t)<<10|(1023&n)<<20;if(!_.has(i)){_.add(i);try{api.setBlock(e,t,n,api.blockIdToBlockName(o))}catch(l){}}},m=1/0,h=-1/0;for(let v of n.selectedPoints.keys()){let[w]=v.split(",").map(Number);m=Math.min(m,w),h=Math.max(h,w)}let C=(m+h)/2,x=()=>{for(let t=0;t<3;t++){if(r>1){if(api.sendMessage(e,"曲線生成・設置完了"),n.lastCurve=l,n.controlPoints=[],d){let o=e=>{let t=l.getPoint(e),[n,o,i]=l.getTangent(e),s=Math.hypot(n,o,i)||1;return{pos:[Math.round(t[0]),Math.round(t[1]),Math.round(t[2])],dir:[n/s,o/s,i/s]}};api.setBlockData(...startCenterPos,{persisted:{shared:{snap:o(0),handleLen:l.getEndHandleLength(),endHandle:[P[0]-g[0],P[1]-g[1],P[2]-g[2],]}}}),api.setBlockData(...endCenterPos,{persisted:{shared:{snap:o(1),handleLen:l.getEndHandleLength(),endHandle:[u[0]-p[0],u[1]-p[1],u[2]-p[2],]}}})}return}let i=l.getPoint(r),[_,$,c]=l.getTangent(r),m=Math.hypot(_,$,c)||1,h=_/m,v=c/m,w=-v,T=h;fillSegment(a,i,(e,t,o)=>{if(void 0!==e&&void 0!==t&&void 0!==o)for(let[i,l]of n.selectedPoints){let[s,r]=i.split(",").map(Number),a=s-C,_=Math.round(e+w*a),$=Math.round(t+r),c=Math.round(o+T*a);f(_,$,c,l)}}),a=i,r+=s}S.run(x,1,`do-${e}`)};return S.run(x,1,`do-${e}`),!0}};
